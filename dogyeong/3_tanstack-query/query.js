export class Query {
  cache
  queryKey
  queryHash
  options
  observers
  state
  promise
  gcTimeout

  constructor(config) {
    this.observers = []
    this.cache = config.cache
    this.queryHash = config.queryHash
    this.queryKey = config.queryKey
    this.options = {
      ...config.defaultOptions,
      ...config.options,
    }
    this.state = {
      data: undefined,
      error: undefined,
      status: 'pending',
      isFetching: true,
      lastUpdated: undefined,
    }

    this.scheduleGcTimeout()
  }

  scheduleGcTimeout = () => {
    const { gcTime } = this.options

    this.gcTimeout = setTimeout(() => {
      this.cache.remove(this)
    }, gcTime)
  }

  clearGcTimeout = () => {
    clearTimeout(this.gcTimeout)
    this.gcTimeout = null
  }

  subscribe = (observer) => {
    this.observers.push(observer)

    this.clearGcTimeout()

    const unsubscribe = () => {
      this.observers = this.observers.filter((o) => {
        return o !== observer
      })

      if (!this.observers.length) {
        this.scheduleGcTimeout()
      }
    }

    return unsubscribe
  }

  setState = (updater) => {
    this.state = updater(this.state)

    this.observers.forEach((observer) => {
      observer.notify()
    })
  }

  fetch = () => {
    if (!this.promise) {
      this.promise = (async () => {
        this.setState((old) => ({ ...old, isFetching: true, error: undefined }))

        try {
          if (!this.options.queryFn) {
            throw new Error(`Missing queryFn: '${this.options.queryHash}'`)
          }

          const data = await this.options.queryFn()

          this.setState((old) => ({
            ...old,
            status: 'success',
            data,
            lastUpdated: Date.now(),
          }))
        } catch (error) {
          this.setState((old) => ({ ...old, status: 'error', error }))
        } finally {
          this.setState((old) => ({ ...old, isFetching: false }))

          this.promise = null
        }
      })()
    }

    return this.promise
  }
}
